/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 rock-scene.glb --transform 
Files: rock-scene.glb [11.17MB] > /Users/cullen/Projects/portfolio-r3f/public/rock-scene-transformed.glb [1.1MB] (90%)
*/

import React, { useRef, useState, useEffect, useMemo } from "react";
import * as THREE from "three";
import {
	MeshTransmissionMaterial,
	MeshReflectorMaterial,
	useGLTF,
	Float,
	Text,
	shaderMaterial,
} from "@react-three/drei";
import { useFrame, useLoader, extend } from "@react-three/fiber";

export function Model(props) {
	const { nodes, materials } = useGLTF("/rock-scene.glb");

	return (
		<group {...props} dispose={null}>
			<mesh
				geometry={nodes.Rock.geometry}
				material={materials.Rock_baked}
				position={[0, 0.189, 0]}
			/>
			<ReflectiveWater />
			<VideoText position={[0, 3, -8]} />
			<mesh geometry={nodes.Teleporter.geometry} position={[0, -0.1, 0]}>
				<MeshTransmissionMaterial
					transmission={0.5}
					color={"#878787"}
					backside
					backsideThickness={10}
					thickness={2}
					roughness={0.05}
					anisotropicBlur={0}
					backsideResolution={0}
				/>
			</mesh>

			<Wires nodes={nodes} />

			<mesh geometry={nodes.Light.geometry} position={[0, 0.3, 0]}>
				<meshPhysicalMaterial
					color={"#50DDFF"}
					roughness={0.5}
					metalness={0.2}
					emissive={"#50DDFF"}
					emissiveIntensity={1}
				/>
			</mesh>
			<mesh geometry={nodes.Light.geometry} position={[0, 0.1, 0]}>
				<meshPhysicalMaterial color={"#000000"} roughness={1.0} metalness={0} />
			</mesh>

			<Float
				speed={3}
				rotationIntensity={1}
				floatIntensity={1}
				floatingRange={[-0.15, 0.15]}
			>
				<Logo nodes={nodes} />
			</Float>
		</group>
	);
}

function Logo({ nodes }) {
	const logoRef = useRef();

	useFrame(() => {
		if (logoRef.current) {
			logoRef.current.rotation.y += 0.02;
		}
	});

	return (
		<group ref={logoRef}>
			<mesh geometry={nodes.logobottom.geometry}>
				<MeshTransmissionMaterial
					backside
					backsideThickness={5}
					thickness={2}
				/>
			</mesh>
			<mesh geometry={nodes.logoleft.geometry}>
				<MeshTransmissionMaterial
					backside
					backsideThickness={5}
					thickness={2}
				/>
			</mesh>
			<mesh geometry={nodes.logoright.geometry}>
				<MeshTransmissionMaterial
					backside
					backsideThickness={5}
					thickness={2}
				/>
			</mesh>
			<mesh geometry={nodes.logotop.geometry}>
				<MeshTransmissionMaterial
					backside
					backsideThickness={5}
					thickness={2}
				/>
			</mesh>
		</group>
	);
}

// Define the custom shader material
const WireShaderMaterial = shaderMaterial(
  // Uniforms
  {
    time: 0, // To animate the emission
    speed: 1, // Speed of the emission flow
    stripWidth: 0.1, // Width of the emission strip
    baseColor: new THREE.Color(0x010101), // Dark gray-black base color
    emissionColor: new THREE.Color(0x50ddff), // Cool blue emission color
    metallic: 0.9, // High metallic factor
    roughness: 0.3, // Slightly rough surface
    tint: new THREE.Color(0x020202), // Subtle blue tint for the reflections
  },
  // Vertex Shader
  `
    varying vec2 vUv; // Pass UV coordinates to the fragment shader
    varying vec3 vNormal; // Pass normal to the fragment shader
    varying vec3 vViewDir; // View direction for fresnel effect

    void main() {
      vUv = uv; // Assign the mesh's UV coordinates
      vNormal = normal; // Assign the vertex normal
      vViewDir = normalize((modelViewMatrix * vec4(position, 1.0)).xyz);

      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  // Fragment Shader
  `
    uniform float time;
    uniform float speed;
    uniform float stripWidth;
    uniform vec3 baseColor;
    uniform vec3 emissionColor;
    uniform float metallic;
    uniform float roughness;
    uniform vec3 tint;

    varying vec2 vUv;
    varying vec3 vNormal;
    varying vec3 vViewDir;

    void main() {
      // Compute the flow for the first strip
      float flow1 = mod(vUv.y + time * speed, 1.0);

      // Compute the flow for the second strip, offset by 0.5
      float flow2 = mod(vUv.y + time * speed + 0.5, 1.0);

      // Create the emission strips
      float strip1 = smoothstep(0.5 - stripWidth, 0.5, flow1) - smoothstep(0.5, 0.5 + stripWidth, flow1);
      float strip2 = smoothstep(0.5 - stripWidth, 0.5, flow2) - smoothstep(0.5, 0.5 + stripWidth, flow2);

      // Combine the strips
      float combinedStrip = max(strip1, strip2);

      // Fresnel effect for metallic look
      float fresnel = pow(1.0 - dot(vNormal, vViewDir), 10.0);

      // Add roughness-based shading
      float roughnessFactor = 1.0 - roughness;

      // Metallic blending with tint
      vec3 tintedBaseColor = mix(baseColor, tint, fresnel * roughnessFactor);
      vec3 finalBaseColor = mix(baseColor, tintedBaseColor, metallic);

      vec3 amplifiedEmission = emissionColor * 4.0 * combinedStrip;
      // Combine base color and emission
      vec3 finalColor = mix(finalBaseColor, amplifiedEmission, combinedStrip);

      // Output the final color
      gl_FragColor = vec4(finalColor, 1.0);
    }
  `
);

// Define the custom shader material
const WireShaderMaterialSmall = shaderMaterial(
  // Uniforms
  {
    time: 0, // To animate the emission
    speed: 0.5, // Speed of the emission flow
    stripWidth: 0.01, // Width of the emission strip
    baseColor: new THREE.Color(0x010101), // Dark gray-black base color
    emissionColor: new THREE.Color(0x50ddff), // Cool blue emission color
    metallic: 0.9, // High metallic factor
    roughness: 0.3, // Slightly rough surface
    tint: new THREE.Color(0x0e131c), // Subtle blue tint for the reflections
  },
  // Vertex Shader
  `
    varying vec2 vUv; // Pass UV coordinates to the fragment shader
    varying vec3 vNormal; // Pass normal to the fragment shader
    varying vec3 vViewDir; // View direction for fresnel effect

    void main() {
      vUv = uv; // Assign the mesh's UV coordinates
      vNormal = normal; // Assign the vertex normal
      vViewDir = normalize((modelViewMatrix * vec4(position, 1.0)).xyz);

      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  // Fragment Shader
  `
    uniform float time;
    uniform float speed;
    uniform float stripWidth;
    uniform vec3 baseColor;
    uniform vec3 emissionColor;
    uniform float metallic;
    uniform float roughness;
    uniform vec3 tint;

    varying vec2 vUv;
    varying vec3 vNormal;
    varying vec3 vViewDir;

    void main() {
      // Compute the flow for the first strip
      float flow1 = mod(vUv.x + time * speed, 1.0);

      // Compute the flow for the second strip, offset by 0.5
      float flow2 = mod(vUv.x + time * speed + 0.5, 1.0);

      // Create the emission strips
      float strip1 = smoothstep(0.5 - stripWidth, 0.5, flow1) - smoothstep(0.5, 0.5 + stripWidth, flow1);
      float strip2 = smoothstep(0.5 - stripWidth, 0.5, flow2) - smoothstep(0.5, 0.5 + stripWidth, flow2);

      // Combine the strips
      float combinedStrip = max(strip1, strip2);

      // Fresnel effect for metallic look
      float fresnel = pow(1.0 - dot(vNormal, vViewDir), 8.0);

      // Add roughness-based shading
      float roughnessFactor = 1.0 - roughness;

      // Metallic blending with tint
      vec3 tintedBaseColor = mix(baseColor, tint, fresnel * roughnessFactor);
      vec3 finalBaseColor = mix(baseColor, tintedBaseColor, metallic);

      vec3 amplifiedEmission = emissionColor * 4.0 * combinedStrip;
      // Combine base color and emission
      vec3 finalColor = mix(finalBaseColor, amplifiedEmission, combinedStrip);

      // Output the final color
      gl_FragColor = vec4(finalColor, 1.0);
    }
  `
);

// Extend the material so it can be used in JSX
extend({ WireShaderMaterial });
extend({ WireShaderMaterialSmall });

function Wires({ nodes }) {
	useFrame((state) => {
		// Update the time uniform for the animation
		state.scene.traverse((child) => {
			if (child.material && child.material.uniforms?.time) {
				child.material.uniforms.time.value += 0.01;
			}
		});
	});
	return (
		<>
			<mesh geometry={nodes.Wiresmall.geometry} position={[9.5, 0.047, -5]}>
				<wireShaderMaterialSmall />
			</mesh>
			<mesh
				geometry={nodes.Wiresmall001.geometry}
				position={[-5.196, -0.291, -2.13]}
			>
				<wireShaderMaterialSmall />
			</mesh>
			<mesh
				geometry={nodes.Wire001.geometry}
				position={[8.543, 0.047, -3.157]}
				rotation={[0, 0, -Math.PI / 2]}
			>
				<wireShaderMaterial />
			</mesh>
			<mesh
				geometry={nodes.Wire.geometry}
				position={[-2.085, 0.116, -1.067]}
				rotation={[0, 0, -Math.PI / 2]}
			>
				<wireShaderMaterial />
			</mesh>
		</>
	);
}

function VideoText(props) {
	const [video] = useState(() =>
		Object.assign(document.createElement("video"), {
			src: "/video.mp4",
			crossOrigin: "Anonymous",
			loop: true,
			muted: true,
			playsInline: true, // Add this attribute
		})
	);
	useEffect(() => void video.play(), [video]);

	const videoTexture = new THREE.VideoTexture(video);
	videoTexture.encoding = THREE.sRGBEncoding;

	return (
		<Text
			font="/bootzy.ttf"
			fontSize={9}
			letterSpacing={0}
			geometryArgs={{ uvGenerator: null }} // Ensure proper UV mapping
			{...props}
		>
			COMPLICIT*
			<meshStandardMaterial
				toneMapped={false}
				emissive={"#50DDFF"}
				emissiveIntensity={2}
				emissiveMap={videoTexture}
			/>
		</Text>
	);
}

function ReflectiveWater() {
	const waterBump = useLoader(THREE.TextureLoader, "/waterbump.png");
	const materialRef = useRef();

	// Scale and animate the distortion
	useFrame((state) => {
		const time = state.clock.getElapsedTime();
		if (materialRef.current) {
			materialRef.current.distortion =
				1 + 2.0 * (1 + Math.sin(time + Math.PI / 4));
		}
	});

	return (
		<mesh
			receiveShadow
			rotation={[-Math.PI / 2, 0, 0]}
			position={[0, -0.18, 0]}
		>
			<planeGeometry args={[20, 20]} />
			<MeshReflectorMaterial
				ref={materialRef}
				blur={[100, 100]}
				mixBlur={1.0}
				mixStrength={180}
				resolution={2048}
				roughness={1.0}
				depthScale={12}
				minDepthThreshold={0.5}
				maxDepthThreshold={0.6}
				color="#555555"
				metalness={0.6}
				distortionMap={waterBump}
				distortion={0.3}
			/>
		</mesh>
	);
}

useGLTF.preload("/rock-scene.glb");
